% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer3_detector.R
\name{slope_layer}
\alias{slope_layer}
\title{Slope Detector Layer}
\usage{
slope_layer(num_rules, num_otus, num_time_centers, layer_name = "slope", ...)
}
\arguments{
\item{num_rules}{Number of rule detectors}

\item{num_otus}{Number of OTUs}

\item{num_time_centers}{Number of time centers (unused, kept for compatibility)}

\item{layer_name}{Name for this layer instance (default: "slope")}

\item{...}{Additional arguments passed to base layer}
}
\value{
An R6 class representing a Slope detector layer
}
\description{
Learn threshold for slope values. The output is a gated response indicating
whether the aggregated slope from spatial and time aggregation steps is
above/below the learned threshold.
}
\details{
Architecture:
\itemize{
\item Input: (batch, num_rules, num_otus)
\item Output: (batch, num_rules, num_otus)
}

Similar to the threshold layer, but operates on slope (rate of change) values
rather than abundance values. Uses sigmoid activation for smooth gating:
\deqn{output = \sigma((x - slope\_threshold) \times k)}

Typically used in conjunction with time_agg_layer which computes slopes.
}
\examples{
\dontrun{
library(torch)

# Create slope detector layer
layer <- slope_layer(
  num_rules = 5,
  num_otus = 20,
  num_time_centers = 1
)

# Forward pass (typically slope values from Layer 2)
x_slope <- torch_randn(32, 5, 20)
output <- layer(x_slope)
print(output$shape)  # [32, 5, 20]

# Integration with Layer 2
time_layer <- time_agg_layer(5, 20, 10, 1)
x_temporal <- torch_randn(32, 5, 20, 10)
result <- time_layer(x_temporal)
slope_detected <- layer(result$slope)
}

}
